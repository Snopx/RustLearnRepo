// 1.指针是一个包含内存地址的变量。这个地址指向一些其他数据
// 智能指针是一类数据结构，它们表现类似于指针，但是也拥有额外的元数据，最明显的，它们拥有一个引用计数。引用计数记录智能指针总共又多少个所有者，并且当没有任何所有者时清楚数据。

// 2.普通引用和智能指针的一个额外区别是：引用只是借用数据的指针，而智能指针则是拥有他们指向的数据。

//智能指针通常使用结构体实现。智能指针区别于常规结构体的显著特诊在于其实现了Deref 和 drop trait。
// 1） Deref trait 允许智能指针结构体实例表现的像引用一样，这样就可以编写既用于引用，又用于智能指针的代码。
// 2） Drop trait 允许我们自定义当智能指针离开作用域时执行的代码。

// 3. 几个标准库中的智能指针：
// Box<T> 用于 堆 上分配
// Rc<T> ,一个引用计数类型，其数据可以有多个所有者
// Ref<T> 和 RefMut<T> ，通过RefCell<T> 访问，一个在运行时而不是在编译时执行借用规则的类型

// 最简单最直接的智能指针是 Box<T>,允许将值放在堆上，而不是栈上，留在栈上的则是指向堆数据的指针，除了数据存储在堆上，box没有任何的性能损失
// Box<T> 适用于如下场景：
// 1. 当有一个编译时位置大小的类型，有需要在确切的大小的上下文中使用这个类型值的时候；（例：在一个list环境下，存放数据，但是每个元素的大小在编译时又不确定）
// 2. 当有大量数据并且希望在确保数据不被拷贝的情况下转移所有权的时候；
// 3. 当希望拥有一个值并只关心它的类型是否实现了特定的trait而不是其具体类型时。

pub mod smart_pointer {
    pub fn box_lean() {
        let b = Box::new(5);
        println!("{}", b);
        use List::{Cons, Nil};
        let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
        println!("{:?}", list);
    }
    // eps 1: 场景 链表
    #[derive(Debug)]
    pub enum List {
        Cons(i32, Box<List>),
        Nil,
    }
}
